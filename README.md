# Quantum Checkers

For my Quantum Information and Computation class I built this simulation of a rather obtuse game. Essentially, this game involves two qubits which propagate over discrete space in discrete time increments of 1/N. They also have a combined spin state which begins in a heavily entangled state. When they agree on 1, but not both, of their coordinates (when measured), their spin will be passed through a CNOT gate, controlled by the qubit with the more positive coordinate. For times when this agreement is not the case, one will be passed through an Hadamard gate with 50-50 probability of being either qubit.

The second part that makes this an actual game is that there are two players competing for points. When the qubits agree on only one coordinate, one player has a choice (they alternate). They can choose to apply a pauli matrix (X, Y, Z) to the qubit that was previously left alone and measure the spin (so measure the spin in the direction PauliX ⊗ I₂ or I₂ ⊗ PauliX (or PauliY or PauliZ)). The measured spin will be added to their score (so either +1 or -1). The player can also choose to do nothing/skip. 

## Implementation

I used [GameZero.jl](https://github.com/aviks/GameZero.jl) to render what was happening to a simple game window. This was a questionable choice, however it appeared to be the only game engine for Julia and I didn't want to do the amount of linear algebra required for this project in python (let alone an actual game engine using C# or something). Anyway, I am not going to talk anymore about rendering, just so that I have this somewhere.

For propagating the location of the qubits, I used a solution for the Schrodinger that allowed for discrete space and time. The state for the qubit being in any sqaure is calculated using propagation of states from all other squares. This was a lot of nested sums; however, I calculate this after each measurement meaning that probabilities are already stored when the user "measures" (it has already been measured) meaning that this isn't that impactful on performance (and it isn't a ton of calculations anyways). Upon finding probabilities from these states, I use this to randomly sample from the possible locations using these probabilities. This gives me the location of both qubits after each measurement. 

After I finished creating the propagation of locations, I then needed to update spin according to the necessary rules. This simply involved doing a check for the same coordinate, if this was true figuring out if I needed to apply a swap matrix to the spin state such that the CNOT was controlled by the correct qubit or not, and then applying the CNOT, and then swapping back if necessary. If I don't need to apply the CNOT, I just randomly choose to apply the Hadamard to one of the qubits. 

This gives me all the basic spin and location logic for the game. From here, I just implemented logic for measuring spin based on a pauli matrix applied to the last left alone qubit. This simply involved calculating probabilities from the eigenvectors of a matrix and the current spin state and then sampling from these probabilities. Then, I just grab the coorisponding eigenvector to the sampled eigenvalue (-1 or +1) and set the spin state to this eigenvector. I record the score and move on. 